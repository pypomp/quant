{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Cholera\n",
        "jupyter: python3\n",
        "embed-resources: true\n",
        "format: \n",
        "    html:\n",
        "        page-layout: full\n",
        "---\n",
        "\n",
        "\n",
        "Adapted from github:hetankevin/diffPomp/cholera.ipynb\n",
        "using quarto convert cholera.ipynb\n"
      ],
      "id": "b32b0264"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: scaling\n",
        "J = 20 # number of particles, KT used 10^4\n",
        "TRIALS = 5 # number of replicates, KT used 10^2\n",
        "IF2_ITS = 5 # IF2 iterations, KT used 60\n",
        "SGD_ITS = 5 # SGD steps, KT used 100\n",
        "PF_REPS = 5 # replications of PF, KT used 30"
      ],
      "id": "scaling",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: imports\n",
        "\n",
        "import os\n",
        "#os.environ['XLA_PYTHON_CLIENT_PREALLOCATE']='false'\n",
        "\n",
        "import jax\n",
        "import itertools\n",
        "import numpy as onp\n",
        "import ptitprince as pt\n",
        "\n",
        "import jax.numpy as np\n",
        "import ipywidgets as widgets\n",
        "import pandas as pd\n",
        "\n",
        "from jax.numpy.linalg import inv, pinv\n",
        "from jax.scipy.optimize import minimize\n",
        "from scipy.linalg import solve_discrete_are as dare\n",
        "from jax import jit, grad\n",
        "from IPython import display\n",
        "from toolz.dicttoolz import valmap, itemmap\n",
        "from itertools import chain\n",
        "from functools import partial\n",
        "\n",
        "from tqdm.notebook import tqdm\n",
        "from tensorflow_probability.substrates import jax as tfp\n",
        "tfd = tfp.distributions\n",
        "tfb = tfp.bijectors\n",
        "tfpk = tfp.math.psd_kernels\n",
        "\n",
        "from pomps import *\n",
        "from resampling import *\n",
        "from filtering import *\n",
        "from optim import *\n",
        "\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "# this is perhaps a reference to a setup file of Kevin's\n",
        "# plt.style.use('matplotlibrc') \n",
        "\n",
        "onp.set_printoptions(suppress=True)"
      ],
      "id": "imports",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: build model\n",
        "dataset = pd.read_csv('data/dacca/dacca.csv', index_col=0).reset_index(drop=True)\n",
        "ys = np.array(dataset['cholera.deaths'].values)\n",
        "dataset = pd.read_csv('data/dacca/covars.csv', index_col=0).reset_index(drop=True)\n",
        "dataset.index = pd.read_csv('data/dacca/covart.csv', index_col=0).reset_index(drop=True).squeeze()\n",
        "dataset = dataset.reindex(onp.array([1891 + i*(1/240) for i in range(12037)])).interpolate()\n",
        "covars = np.array(dataset.values)#[20:]\n",
        "#gamma, m, rho, epsilon, omega, c, beta_trend, sigma, tau, bs, k, delta = 8.0, 9.238, 7.1, 0.7, onp.exp(-4.5), 0.0051, (-6.8*10**(-3)), 639.6, 0.23, np.array([6.5,11.4,2.1,9.0,8.6,9.5]), 3, 0.02\n",
        "#gamma, m, rho, epsilon, omega, c, beta_trend, sigma, tau, bs, k, delta = 17.3, 0.057, 0, 9.8, onp.exp(-4.8), 0.999999, (-5.0*10**(-3)), 3.2, 0.25, np.array([1.2,6.2,-3.4,3.9,3.2,4.3]), 3, 0.02\n",
        "\n",
        "\n",
        "gamma = 20.8\n",
        "epsilon = 19.1\n",
        "rho = 0\n",
        "delta = 0.02\n",
        "m = 0.06\n",
        "c = np.array(1)\n",
        "beta_trend = -0.00498\n",
        "bs = np.array([0.747, 6.38, -3.44, 4.23, 3.33, 4.55])\n",
        "sigma = 3.13 #3.13 # 0.77\n",
        "tau = 0.23 \n",
        "omega = onp.exp(-4.5)\n",
        "omegas = np.log(np.array([0.184, 0.0786, 0.0584, 0.00917, 0.000208, 0.0124]))\n",
        "\n",
        "\n",
        "theta = transform_thetas(gamma, m, rho, epsilon, omega, c, beta_trend, sigma, tau, bs, omegas)"
      ],
      "id": "build-model",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: repeat pfilter\n",
        "\n",
        "reps = [pfilter(theta, ys, J+i, covars, thresh=-1) for i in range(PF_REPS)]\n",
        "# changing J here may just be a way to avoid identical results without changing the key"
      ],
      "id": "repeat-pfilter",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "onp.std(reps)"
      ],
      "id": "78b2b383",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "onp.mean(reps)"
      ],
      "id": "94c38ab6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "0.5843911*3"
      ],
      "id": "08fc24af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mop(theta, ys, J, covars, alpha=0.5)"
      ],
      "id": "02d09860",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "jgrad(theta, ys, J, covars, -1)"
      ],
      "id": "eca36e24",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: set up thetas and sigmas; one pfilter test\n",
        "n_trials = TRIALS\n",
        "\n",
        "def get_rand_theta():\n",
        "    return transform_thetas(onp.random.uniform(10.00, 40.00),\n",
        "                onp.random.uniform(0.03, 0.60), \n",
        "                         rho, \n",
        "                 onp.random.uniform(0.20, 30.00), \n",
        "                         omega, \n",
        "                         c, \n",
        "                 onp.random.uniform(-1.00, 0.00)*0.01, \n",
        "                 onp.random.uniform(1.00, 5.00), \n",
        "                 onp.random.uniform(0.10, 0.50), \n",
        "                 onp.random.uniform(0,8,size=6)+np.array([-4,0,-4,0,0,0]), \n",
        "                 onp.random.uniform(-10,0,size=6))\n",
        "\n",
        "def get_sds():    \n",
        "    lows = transform_thetas(10.00,0.03, rho, 0.20, omega, c, \n",
        "             -1.00*0.01, 1.00, 0.10, \n",
        "             onp.zeros(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "            -10*onp.ones(6))\n",
        "    highs = transform_thetas(40.00,0.60, rho, 30.00, omega, c, \n",
        "                 0.00, 5.00, 0.50, \n",
        "                 8*onp.ones(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "                onp.zeros(6))\n",
        "    return (highs-lows)/100\n",
        "\n",
        "\n",
        "\n",
        "def get_rand_theta(J=J):\n",
        "    lows = transform_thetas(10.00,0.03, rho, 0.20, omega, c, \n",
        "             -1.00*0.01, 1.00, 0.10, \n",
        "             onp.zeros(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "            -10*onp.ones(6))\n",
        "    highs = transform_thetas(40.00,0.60, rho, 30.00, omega, c, \n",
        "                 0.00, 5.00, 0.50, \n",
        "                 8*onp.ones(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "                onp.zeros(6))\n",
        "    rands = onp.array(onp.repeat(((lows+highs)/2)[None,:], J, axis=0)).T\n",
        "    rands[~onp.isinf(lows)] = onp.random.uniform(lows[~onp.isinf(lows)], \n",
        "                       highs[~onp.isinf(highs)],\n",
        "                       size=(J, len(highs[~onp.isinf(highs)]))).T\n",
        "    return rands.T\n",
        "                       \n",
        "                       \n",
        "\n",
        "\n",
        "sigmas = (np.abs(theta)/600)\n",
        "theta_ests = theta + 60*sigmas*onp.random.normal(size=theta.shape) #6 for close to maxima\n",
        "#theta_ests = get_rand_theta(J).mean(0)\n",
        "\n",
        "'''\n",
        "gd_logliks, gd_ests = train(theta_ests, ys, covars, beta=0.9, eta=5e-4/600,\n",
        "                            verbose=True, itns=20, J=J, thresh=0, method='SGD', scale=False)\n",
        "\n",
        "\n",
        "newt_logliks, newt_ests = train(theta_ests, ys, covars, beta=0.9, eta=1e-2, c=1e-1, max_ls_itn=5, \n",
        "                            verbose=True, itns=20, J=J, Jh=500, thresh=0, method='Newton', scale=True, ls=True)\n",
        "\n",
        "'''\n",
        "print(pfilter(theta_ests, ys, J, covars, thresh=-1))\n",
        "#res = minimize(pfilter, x0=theta_ests, args=(ys, J, covars, 0), method='BFGS', options={'maxiter': 10})\n",
        "get_thetas(theta_ests)\n",
        "\n",
        "# try cross-comparison, fig 2 in pnas, on close to MLE\n",
        "# use if2 settings"
      ],
      "id": "set-up-thetas-and-sigmas-one-pfilter-test",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def log_in_bbox(theta):    \n",
        "    valids = np.array([i for i in range(len(theta)) if i not in [2,5]])\n",
        "    lows = transform_thetas(10.00,0.03, rho, 0.20, omega, c, \n",
        "             -1.00*0.01, 1.00, 0.10, \n",
        "             onp.zeros(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "            -10*onp.ones(6))\n",
        "    highs = transform_thetas(40.00,0.60, rho, 30.00, omega, c, \n",
        "                 0.00, 5.00, 0.50, \n",
        "                 8*onp.ones(6)+onp.array([-4,0,-4,0,0,0]), \n",
        "                onp.zeros(6))\n",
        "    #theta = highs+1\n",
        "    #theta = lows-1\n",
        "    return -100*np.log(1-(np.logical_or(np.any(lows[valids] > theta[valids]),\n",
        "                                        np.any(theta[valids] > highs[valids])))+1e-43)\n",
        "\n",
        "log_in_bbox(theta+9999)"
      ],
      "id": "4c49f662",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: big search\n",
        "n_trials = TRIALS\n",
        "close = False\n",
        "\n",
        "\n",
        "#bbox = np.load('bbox.npy')\n",
        "\n",
        "original_logliks = []\n",
        "original_theta_ests = []\n",
        "\n",
        "mif_logliks_trials = []\n",
        "mif_params_trials = []\n",
        "\n",
        "mif_logliks_warm_trials = []\n",
        "mif_params_warm_trials = []\n",
        "\n",
        "gd_logliks_trials = []\n",
        "gd_ests_trials = []\n",
        "\n",
        "gd_logliks_pf_trials = []\n",
        "gd_ests_pf_trials = []\n",
        "\n",
        "gd_logliks_mop_trials = []\n",
        "gd_ests_mop_trials = []\n",
        "\n",
        "\n",
        "\n",
        "gd_logliks_raw_trials = []\n",
        "gd_ests_raw_trials = []\n",
        "gd_logliks_pf_raw_trials = []\n",
        "gd_ests_pf_raw_trials = []\n",
        "\n",
        "\n",
        "for trial in tqdm(range(n_trials)):\n",
        "    \n",
        "    if close:\n",
        "        sigmas = (np.abs(theta)/600)\n",
        "        theta_ests = theta + 60*sigmas*onp.random.normal(size=theta.shape) #6 for close to maxima\n",
        "        orig_loglik = pfilter(theta_ests, ys, J, covars, thresh=-1)\n",
        "        gd_logliks, gd_ests = train(theta_ests, ys, covars, beta=0.9, \n",
        "                            eta=np.flip(np.linspace(0.0001,0.1,SGD_ITS)), \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=True)\n",
        "    else:\n",
        "        bbox = get_rand_theta(1).squeeze()# np.array([get_rand_theta() for j in tqdm(range(J))])\n",
        "        orig_loglik = pfilter(bbox, ys, J, covars, thresh=-1)\n",
        "        mif_logliks_warm, mif_params_warm = mif(bbox, ys, sigmas=0.02, \n",
        "                                  sigmas_init = 1e-20, covars=covars, verbose=False,\n",
        "                                  M=IF2_ITS, J=J, a=0.95, monitor=True, thresh=-1) \n",
        "        theta_ests = mif_params_warm[mif_logliks_warm.argmin()].mean(0)\n",
        "        \n",
        "        \n",
        "        gd_logliks, gd_ests = train(theta_ests, ys, covars, beta=0.9, \n",
        "                            eta=0.01, \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=False, alpha=1)  #(0.0001,0.2,60)\n",
        "        gd_logliks_pf, gd_ests_pf = train(theta_ests, ys, covars, beta=0.9, \n",
        "                            eta=0.05, \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=False, alpha=0) \n",
        "        gd_logliks_mop, gd_ests_mop = train(theta_ests, ys, covars, beta=0.9, \n",
        "                            eta=0.2, \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=False, alpha=0.97) #0.97 \n",
        "        #mif_logliks = mif_logliks_warm\n",
        "        #mif_params = mif_params_warm\n",
        "        #np.flip(np.linspace(0.0001,0.2,60)\n",
        "        \n",
        "        mif_logliks, mif_params = mif(bbox, ys, sigmas=0.02, \n",
        "                                  sigmas_init = 1e-20, covars=covars, verbose=False,\n",
        "                                  M=IF2_ITS, J=J, a=0.95, monitor=True, thresh=-1) #0.99\n",
        "        \n",
        "        '''\n",
        "        gd_logliks_raw, gd_ests_raw = train(bbox, ys, covars, beta=0.9, \n",
        "                            eta=np.flip(np.linspace(0.0001,0.2,100)), \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=True, alpha=1) \n",
        "        gd_logliks_pf_raw, gd_ests_pf_raw = train(bbox, ys, covars, beta=0.9, \n",
        "                            eta=np.flip(np.linspace(0.0001,0.2,SGD_ITS)), \n",
        "                            verbose=False, itns=SGD_ITS, J=J, thresh=100, \n",
        "                            method='SGD', ls=False, scale=True, alpha=0) \n",
        "        '''\n",
        "\n",
        "    #theta_ests = bbox[trial]\n",
        "    #\n",
        "    '''\n",
        "    mif_logliks, mif_params = mif(theta_ests, ys, sigmas=0.01*sigmas, \n",
        "                              sigmas_init = 60*sigmas, covars=covars, verbose=False,\n",
        "                              M=IF2_ITS, J=J, a=0.99, monitor=True, thresh=-1)\n",
        "                              \n",
        "    \n",
        "    '''\n",
        "    \n",
        "    \n",
        "    original_logliks.append(orig_loglik)\n",
        "    original_theta_ests.append(theta_ests)\n",
        "    \n",
        "    \n",
        "    outf = open('outs/log/trials'+str(trial)+'.txt', 'w')\n",
        "    outf.write(str(trial) + 'orig ' + str(orig_loglik) + ' gd ' + str(gd_logliks[-1]) + ' , ' + str(min(gd_logliks)) + ' mif ' + str(mif_logliks[-1]) + ' , ' + str(min(mif_logliks)))\n",
        "    \n",
        "    print('orig', orig_loglik, 'gd', gd_logliks[-1], 'if2', mif_logliks[-1])\n",
        "    \n",
        "    mif_logliks_trials.append(mif_logliks)\n",
        "    mif_params_trials.append(mif_params)\n",
        "    \n",
        "    mif_logliks_warm_trials.append(mif_logliks_warm)\n",
        "    mif_params_warm_trials.append(mif_params_warm)\n",
        "    \n",
        "    gd_logliks_trials.append(gd_logliks)\n",
        "    gd_ests_trials.append(gd_ests)\n",
        "    \n",
        "    gd_logliks_pf_trials.append(gd_logliks_pf)\n",
        "    gd_ests_pf_trials.append(gd_ests_pf)\n",
        "    \n",
        "    gd_logliks_mop_trials.append(gd_logliks_mop)\n",
        "    gd_ests_mop_trials.append(gd_ests_mop)\n",
        "    \n",
        "    '''\n",
        "    gd_logliks_raw_trials.append(gd_logliks_raw)\n",
        "    gd_ests_raw_trials.append(gd_ests_raw)\n",
        "    \n",
        "    \n",
        "    gd_logliks_pf_raw_trials.append(gd_logliks_pf_raw)\n",
        "    gd_ests_pf_raw_trials.append(gd_ests_pf_raw)\n",
        "    '''\n",
        "    \n",
        "\n",
        "# try cross-comparison, fig 2 in pnas, on close to MLE\n",
        "# use if2 settings\n",
        "\n",
        "\n",
        "## the remainder of this chunk seems to duplicate the next one\n",
        "suff = '-095mop-constantlr01052-2'#'-095mop-constantlr01052-2'\n",
        "file = ''\n",
        "np.save('outs/ifad/mif_logliks_trials'+suff+file+'.npy', np.array(mif_logliks_trials))\n",
        "np.save('outs/ifad/mif_logliks_warm_trials'+suff+file+'.npy', np.array(mif_logliks_warm_trials))\n",
        "np.save('outs/ifad/gd_logliks_trials'+suff+file+'.npy', np.array(gd_logliks_trials))\n",
        "np.save('outs/ifad/gd_logliks_pf_trials'+suff+file+'.npy', np.array(gd_logliks_pf_trials))\n",
        "np.save('outs/ifad/gd_logliks_mop_trials'+suff+file+'.npy', np.array(gd_logliks_mop_trials))"
      ],
      "id": "big-search",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: save search output\n",
        "suff = '-095mop-constantlr01052-2'#'-095mop-constantlr01052-2'\n",
        "file = ''\n",
        "np.save('outs/ifad/mif_logliks_trials'+suff+file+'.npy', np.array(mif_logliks_trials))\n",
        "np.save('outs/ifad/mif_logliks_warm_trials'+suff+file+'.npy', np.array(mif_logliks_warm_trials))\n",
        "np.save('outs/ifad/gd_logliks_trials'+suff+file+'.npy', np.array(gd_logliks_trials))\n",
        "np.save('outs/ifad/gd_logliks_pf_trials'+suff+file+'.npy', np.array(gd_logliks_pf_trials))\n",
        "np.save('outs/ifad/gd_logliks_mop_trials'+suff+file+'.npy', np.array(gd_logliks_mop_trials))"
      ],
      "id": "save-search-output",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: reload saved searches\n",
        "\n",
        "\n",
        "#files = ['','-1','-2']\n",
        "# it seems that here we only have '_2'. The others may have been run elsewhere\n",
        "files = ['-2']\n",
        "\n",
        "pref = '-095mop-constantlr01052'\n",
        "mif_logliks_trials = np.vstack([np.load('outs/ifad/mif_logliks_trials'+pref+file+'.npy')\n",
        "                               for file in files])[:TRIALS]\n",
        "\n",
        "mif_logliks_warm_trials = np.vstack([np.load('outs/ifad/mif_logliks_warm_trials'+pref+file+'.npy')\n",
        "                               for file in files])[:TRIALS]\n",
        "\n",
        "gd_logliks_trials = np.vstack([np.load('outs/ifad/gd_logliks_trials'+pref+file+'.npy')\n",
        "                               for file in files])[:TRIALS]\n",
        "\n",
        "gd_logliks_mop_trials = np.vstack([np.load('outs/ifad/gd_logliks_mop_trials'+pref+file+'.npy')\n",
        "                               for file in files])[:TRIALS]\n",
        "\n",
        "gd_logliks_pf_trials = np.vstack([np.load('outs/ifad/gd_logliks_pf_trials'+pref+file+'.npy')\n",
        "                               for file in files])[:TRIALS]"
      ],
      "id": "reload-saved-searches",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# MOP IF2 0.95 Constant Learning Rate 0.01, 0.05, 0.2\n"
      ],
      "id": "ae610b45"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: plot mop vs if2\n",
        "#IF2 0.95\n",
        "quantiles = [0,0.5,0.8]\n",
        "mif_runs = pd.DataFrame(mif_logliks_trials).quantile(quantiles).T.astype(float)\n",
        "mif_warm_runs = pd.DataFrame(mif_logliks_warm_trials).quantile(quantiles).T.astype(float)\n",
        "gd_runs = pd.DataFrame(gd_logliks_trials).quantile(quantiles).T.astype(float)\n",
        "gd_mop_runs = pd.DataFrame(gd_logliks_mop_trials).quantile(quantiles).T.astype(float)\n",
        "gd_pf_runs = pd.DataFrame(gd_logliks_pf_trials).quantile(quantiles).T.astype(float)\n",
        "gd_runs.index += 41\n",
        "gd_pf_runs.index += 41\n",
        "gd_mop_runs.index += 41\n",
        "\n",
        "plt.figure(figsize=(5,4))\n",
        "\n",
        "mif_runs[quantiles[1]].plot(label='IF2', linestyle='solid')\n",
        "mif_warm_runs[quantiles[1]].plot(label='IF2 Warm-Start', linestyle='solid')\n",
        "gd_runs[quantiles[1]].plot(label='IFAD-1')\n",
        "gd_pf_runs[quantiles[1]].plot(label='IFAD-0')\n",
        "gd_mop_runs[quantiles[1]].plot(label='IFAD-097')\n",
        "\n",
        "plt.fill_between(mif_runs.index,\n",
        "                 mif_runs[quantiles[0]],\n",
        "                mif_runs[quantiles[2]], alpha=0.2)\n",
        "plt.fill_between(mif_warm_runs.index,\n",
        "                 mif_warm_runs[quantiles[0]],\n",
        "                mif_warm_runs[quantiles[2]], alpha=0.2)\n",
        "plt.fill_between(gd_runs.index,\n",
        "                 gd_runs[quantiles[0]],\n",
        "                gd_runs[quantiles[2]], alpha=0.2)\n",
        "plt.fill_between(gd_runs.index,\n",
        "                 gd_pf_runs[quantiles[0]],\n",
        "                gd_pf_runs[quantiles[2]], alpha=0.2)\n",
        "plt.fill_between(gd_runs.index,\n",
        "                 gd_mop_runs[quantiles[0]],\n",
        "                gd_mop_runs[quantiles[2]], alpha=0.2)\n",
        "plt.axhline(np.median(np.array(mif_logliks_warm_trials), 0)[-1], \n",
        "            linestyle='dashed', color='orange', alpha=1, label='Median Warm-Start')\n",
        "plt.axhline(3748.5, linestyle='dotted', color='red', alpha=0.5, label='MLE')\n",
        "plt.legend()\n",
        "plt.ylim(3745,4000)\n",
        "plt.tight_layout()\n",
        "plt.xlabel('Iterations')\n",
        "plt.ylabel('Negative Log-Likelihood')\n",
        "#plt.title('Optimization Progress of IFAD and IF2')\n",
        "plt.savefig('imgs/095/optim.png', bbox_inches='tight')"
      ],
      "id": "plot-mop-vs-if2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# IF2 0.95\n",
        "plt.figure(figsize=(5,4))\n",
        "# Overall paired searches, our IF2\n",
        "plt.scatter(-(np.array(mif_logliks_trials)[:,-1]), -(np.array(gd_logliks_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-1')\n",
        "plt.scatter(-(np.array(mif_logliks_trials)[:,-1]), -(np.array(gd_logliks_pf_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-0')\n",
        "plt.scatter(-(np.array(mif_logliks_trials)[:,-1]), -(np.array(gd_logliks_mop_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-0.97')\n",
        "lo, hi = -3840, -3740\n",
        "plt.xlim(lo,hi)\n",
        "plt.ylim(lo,hi)\n",
        "plt.plot([lo, hi], [lo, hi], linestyle='--', color='grey')\n",
        "plt.axhline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.axvline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "\n",
        "#plt.title('IFAD v.s. IF2, Paired Searches')\n",
        "\n",
        "plt.xlabel('IF2 Log-Likelihood')\n",
        "plt.ylabel('IFAD Log-Likelihood')\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "# put horizontal and vertical lines at 3748.5\n",
        "plt.text(-3835, -3755, 'A', fontsize=36)\n",
        "\n",
        "plt.savefig('imgs/095/pairs.png', bbox_inches='tight')"
      ],
      "id": "e7ff984f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#IF2 0.95\n",
        "#QQ plot, our IF2\n",
        "plt.figure(figsize=(5,4))\n",
        "plt.scatter(-np.sort(np.array(mif_logliks_trials)[:,-1]), -np.sort(np.array(gd_logliks_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-1')\n",
        "plt.scatter(-np.sort(np.array(mif_logliks_trials)[:,-1]), -np.sort(np.array(gd_logliks_pf_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-0')\n",
        "plt.scatter(-np.sort(np.array(mif_logliks_trials)[:,-1]), -np.sort(np.array(gd_logliks_mop_trials)[:,-1]), marker='o', alpha=0.5,\n",
        "            label='IFAD-0.97')\n",
        "lo, hi = -3840, -3740\n",
        "plt.xlim(lo,hi)\n",
        "plt.ylim(lo,hi)\n",
        "plt.plot([lo, hi], [lo, hi], linestyle='--', color='grey')\n",
        "plt.axhline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.axvline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "#plt.title('IFAD v.s. IF2, Q-Q Plot')\n",
        "plt.xlabel('IF2 Log-Likelihood')\n",
        "plt.ylabel('IFAD Log-Likelihood')\n",
        "plt.legend(loc='lower right')\n",
        "plt.tight_layout()\n",
        "plt.text(-3835, -3755, 'B', fontsize=36)\n",
        "# put horizontal and vertical lines at 3748.5\n",
        "plt.savefig('imgs/095/qq.png', bbox_inches='tight')"
      ],
      "id": "9ac793d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#IF2 0.95\n",
        "import seaborn as sns\n",
        "import pyreadr\n",
        "from scipy.special import logsumexp\n",
        "# plt.style.use('matplotlibrc')\n",
        "result = pyreadr.read_r('data/dacca/cholera-mif1-mif2.rda')\n",
        "\n",
        "length = len(np.array(mif_logliks_trials))\n",
        "data = pd.DataFrame({'IF2 2015': np.pad(logsumexp(result['m2.lik'], axis=0)[:length], \n",
        "                                        (0,max(0,length-TRIALS)), constant_values=np.nan),\n",
        "              'IF2': -(np.array(mif_logliks_trials)[:,-1]),    \n",
        "              'IFAD-1': -(np.array(gd_logliks_trials)[:,-1]),\n",
        "              'IFAD-0' : -(np.array(gd_logliks_pf_trials)[:,-1]),\n",
        "              'IFAD-0.97' : -(np.array(gd_logliks_mop_trials)[:,-1])})\n",
        "\n",
        "#'IF2 Warm Start': -(np.array(mif_logliks_warm_trials)[:,-1]),  \n",
        "\n",
        "'''\n",
        "data = pd.DataFrame({'IF2 2015': np.pad(logsumexp(result['m2.lik'], axis=0)[:length], \n",
        "                                        (0,max(0,length-TRIALS)), constant_values=np.nan),\n",
        "              'IF2': -(np.array(mif_logliks_trials).min(1)),\n",
        "               'IF2 Warm Start': -(np.array(mif_logliks_warm_trials).min(1)),      \n",
        "              'IFAD-1': -(np.array(gd_logliks_trials).min(1)),\n",
        "              'IFAD-0' : -(np.array(gd_logliks_pf_trials).min(1)),\n",
        "              'IFAD-0.97' : -(np.array(gd_logliks_mop_trials).min(1))})\n",
        "'''\n",
        "\n",
        "              #'MOP-1 Alone': -(np.array(gd_logliks_raw_trials)[:-2,-1]),\n",
        "              #'MOP-0 Alone': -(np.array(gd_logliks_pf_raw_trials)[:-2,-1])\n",
        "\n",
        "data[data>-3900].iloc[:,0:].plot.hist(subplots=True, figsize=(8,8),\n",
        "                                       bins=15,\n",
        "                                      xlabel='Log-Likelihood',\n",
        "                                      ylabel='Count', \n",
        "                                     sharex=True, sharey=True)\n",
        "plt.suptitle('Histogram Comparison of IFAD, IF2, and MOP Alone', fontsize=18)\n",
        "plt.axvline(-3748.5, linestyle='dotted', color='r', alpha=0.5, label='MLE')\n",
        "plt.legend()\n",
        "plt.tight_layout()\n",
        "plt.savefig('imgs/095/hist.png', bbox_inches='tight')\n",
        "plt.show()"
      ],
      "id": "7e6fd877",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#IF2 0.95\n",
        "import pyreadr\n",
        "from scipy.special import logsumexp\n",
        "import seaborn as sns\n",
        "# plt.style.use('matplotlibrc')\n",
        "\n",
        "\n",
        "result = pyreadr.read_r('data/dacca/cholera-mif1-mif2.rda')\n",
        "dx=\"group\"; dy=\"score\"; ort=\"h\"; pal = \"Set2\"; sigma = 0.2\n",
        "pal = sns.color_palette([tuple(int(h[i:i+2], 16)/255 for i in (0, 2, 4)) \n",
        "                         for h in ['00BEFF', 'D4CA3A', 'FF6DAE', '67E1B5', 'EBACFA', \n",
        "                                   '9E9E9E', 'F1988E', '5DB15A', 'E28544', '52B8AA']], 10)\n",
        "fig, ax = plt.subplots(figsize=(7/1.2, 5/1.2))\n",
        "\n",
        "ax=pt.RainCloud(x = 'variable', y = 'value', \n",
        "                data = data.rolling(10).max().iloc[9:, :][::10].melt(), bw = sigma,\n",
        "                palette=pal,\n",
        "                 width_viol = 1.2, ax = ax, orient = ort)\n",
        "plt.xlabel('')\n",
        "plt.ylabel('Log-Likelihood')\n",
        "\n",
        "\n",
        "plt.axvline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.ylabel('Log-Likelihood', fontsize=20)\n",
        "plt.xticks(rotation=30, fontsize=16)\n",
        "plt.yticks(rotation=0, fontsize=16)\n",
        "#plt.title('Boxplot Comparison of Performance, Best of 10 Runs')\n",
        "plt.tight_layout()\n",
        "plt.text(-3807.8, 0, 'A', fontsize=36)\n",
        "plt.savefig('imgs/095/boxplot.png', bbox_inches='tight')\n",
        "plt.show()"
      ],
      "id": "794ce2e3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#IF2 0.95\n",
        "import pyreadr\n",
        "from scipy.special import logsumexp\n",
        "import seaborn as sns\n",
        "# plt.style.use('matplotlibrc')\n",
        "plt.figure(figsize=(5,4))\n",
        "result = pyreadr.read_r('data/dacca/cholera-mif1-mif2.rda')\n",
        "dx=\"group\"; dy=\"score\"; ort=\"h\"; pal = \"Set2\"; sigma = 0.2\n",
        "pal = sns.color_palette([tuple(int(h[i:i+2], 16)/255 for i in (0, 2, 4)) for h in ['00BEFF', 'D4CA3A', 'FF6DAE', '67E1B5', 'EBACFA', \n",
        "                                             '9E9E9E', 'F1988E', '5DB15A', 'E28544', '52B8AA']], 10)\n",
        "fig, ax = plt.subplots(figsize=(7/1.2, 5/1.2))\n",
        "\n",
        "ax=pt.RainCloud(x = 'variable', y = 'value', \n",
        "                data = data[data>-3900].melt(), bw = sigma,\n",
        "                palette=pal,\n",
        "                 width_viol = 1.2, ax = ax, orient = ort)\n",
        "plt.xlabel('')\n",
        "plt.ylabel('Log-Likelihood')\n",
        "\n",
        "\n",
        "plt.axvline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.ylabel('Log-Likelihood', fontsize=20)\n",
        "plt.xticks(rotation=30, fontsize=16)\n",
        "plt.yticks(rotation=0, fontsize=16)\n",
        "#plt.title('Boxplot Comparison of Performance, Best of 10 Runs')\n",
        "plt.tight_layout()\n",
        "plt.text(-3895, 0, 'B', fontsize=36)\n",
        "plt.savefig('imgs/095/boxplot_all.png', bbox_inches='tight')\n",
        "plt.show()"
      ],
      "id": "ebca99c2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pd.DataFrame({'Best Log-Likelihood': data.max(0).sort_values(ascending=False).astype(float).round(1),\n",
        "              'Rank': data.max(0).rank(ascending=False).sort_values().astype(int)}).to_latex(\n",
        "            'imgs/095/table.tex', index=True, float_format=\"{:.1f}\".format)"
      ],
      "id": "23f263a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# IF2 0.95\n",
        "plt.figure(figsize=(5,4))\n",
        "ax = sns.boxplot(data,\n",
        "                showfliers = False)\n",
        "sns.stripplot(data,\n",
        "             alpha=0.2, color='black')\n",
        "plt.axhline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.ylim(-6900,-3745)\n",
        "plt.xticks(rotation=45)\n",
        "plt.ylabel('Log-Likelihood')\n",
        "#plt.title('Boxplot Comparison of Performance, All Methods')\n",
        "plt.tight_layout()\n",
        "plt.savefig('imgs/095/boxplotall.png', bbox_inches='tight')\n",
        "plt.show()\n",
        "\n",
        "#IF2 0.95\n",
        "import pyreadr\n",
        "from scipy.special import logsumexp\n",
        "import seaborn as sns\n",
        "# plt.style.use('matplotlibrc')\n",
        "plt.figure(figsize=(5,4))\n",
        "result = pyreadr.read_r('data/dacca/cholera-mif1-mif2.rda')\n",
        "ax = sns.boxplot(data.rolling(10).max().iloc[9:, :][::10],\n",
        "                showfliers = False)\n",
        "sns.stripplot(data.rolling(10).max().iloc[9:, :][::10],\n",
        "             alpha=0.2, color='black')\n",
        "plt.axhline(-3748.5, linestyle='dotted', color='r', alpha=0.5)\n",
        "plt.ylabel('Log-Likelihood')\n",
        "plt.xticks(rotation=45)\n",
        "#plt.title('Boxplot Comparison of Performance, Best of 10 Runs')\n",
        "plt.tight_layout()\n",
        "plt.savefig('imgs/095/boxplot.png', bbox_inches='tight')\n",
        "plt.show()\n"
      ],
      "id": "af5b7bed"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/ionides/git/quant/diffPomp/.diffPomp3-10/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}